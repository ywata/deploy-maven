#!/usr/bin/env perl

@Bins = ("/bin/", "/usr/bin/");
$TAR = "tar";
$SVN = "svn";
$RM  = "/bin/rm";
$CURL = "curl";
$INSTALL = "install";

$BINDIR = "$ENV{HOME}/bin_";
$JAVA_HOME = "java_home";
$MAVEN_VER = "3.3.3";

$BUILD_VERSION_FILE = ".build_version";

$CHROOT = "chroot";

$TAR = &findFile($TAR, @Bins);
$SVN = &findFile($SVN, @Bins);
$CURL = &findFile($CURL, @Bins);
$INSTALL = &findFile($INSTALL, @Bins);

$REMOTE = "remotehost:/home/users/";
    
$build_started = `date "+%Y%m%d-%H%M"`;
chomp($build_started);

    
chomp($cwd = `pwd`); # /bin/pwd

# main function is command dispatcher
&dispatch_(@ARGV);

sub dispatch_{
    my(@argv) = @ARGV;
    my($command) = shift @argv; # 
    my($r);
    
    print "ARGV:@ARGV \n";
    print "argv:@argv \n";
    
    if($ARGV[0] eq "setup"){
	&do_setup_(@argv);
    }elsif($ARGV[0] eq "fetch"){
	# XXX 
	&fetch("http://download.oracle.com/otn-pub/java/jdk/8u60-b27/jdk-8u60-linux-x64.tar.gz", 
	       "Cookie: oraclelicense=accept-securebackup-cookie");
	&fetch("http://ftp.yz.yamagata-u.ac.jp/pub/network/apache/maven/maven-3/3.3.3/binaries/apache-maven-3.3.3-bin.tar.gz")
    }elsif(($ARGV[0] eq "checkout")){
	&writeVersion_($BUILD_VERSION_FILE, "", "");
	&do_checkout_("checkout", @argv);
    }elsif(($ARGV[0] eq "tag-checkout")){
	die "tag-checkout currently not supported.";
	&writeVersion_($BUILD_VERSION_FILE, "tag", $argv[0]);
	my($opt) = " checkout" . shift @argv;
	&do_checkout_($opt, @argv);
    }elsif(($ARGV[0] eq "rev-checkout")){
	&writeVersion_($BUILD_VERSION_FILE, "rev", $argv[0]);
	my($opt) = "checkout  -r " . shift @argv;
	&do_checkout_($opt, @argv);
    }elsif(($ARGV[0] eq "build")){
	my($t, $v) = &readVersion_($BUILD_VERSION_FILE);
	&do_build_($t, $v, @argv);
    }elsif(($ARGV[0] eq "transfer")){
	my($t, $v) = &readVersion_($BUILD_VERSION_FILE);
	&do_transfer_($t, $v, @argv);
    }elsif(($ARGV[0] eq "get-license")){
	&do_get_license_(@argv);
    }elsif($ARGV[0] eq "purge"){
	&do_purge_checkout_(@argv);
    }else{
	&usage_();
    }
}


sub do_setup_{
    my($jdk, $maven) = @_;
    my $j = &untar_($BINDIR, $jdk);
    my $m = &untar_($BINDIR, $maven);
    
    my($mvn) =<< "END_OF_MVN";
#!/bin/sh

export JAVA_HOME=$BINDIR/$jdk
args=\$*

for opt in $args; do
  case "$opt" in
    "--show-java-home") echo "/Users/ywata/bin_/$d"; exit 0;;
    "--show-mvn") echo "depgen.pl" ; exit 0;;
  esac
done

/Users/ywata/bin_/$m/bin/mvn \$*
END_OF_MVN
    &create_script_($BINDIR, "mvn", $mvn);
}

sub do_checkout_{
    my($opt, @argv) = @_;
    `$SVN $opt @argv`;
    if($?){
	
    }
    
}


sub do_build_{
    my($t, $v, @dirs) = @_; 
    print STDERR "do_build_:@dirs\n";

#    my($show_info) = `mvn --show-info`;
    chomp($show_info);

    $? = 0; # XXX
    if($?){
	die "mvn --show-info failed. This means we are not using mvn wrapper generated by $0 setup.";
    }
    
    if($0 =~ m|$show_info|){
    }else{
	die "Non mvn wrapper is used as psuedo mvn.";
    }

    my @deps;
    foreach my $d (@dirs){
	chdir $d || die "cd $d failed";
	`mvn clean dependency:copy-dependencies package`;
	if($?){
	    print "$d mvn failed";
	}
	my @dp = &get_dependencies($d);
	push @deps, @dp;
	chdir $cwd || die "cd $cwd failed";
    }
    &create_archive($t, $v, @dirs);
}

sub do_transfer_{
    my($tag, $ver, $file, $remote, @hosts) = @_;
    my(@path) = split /\//, $file;

    if(-f $file ){
	&run_("scp $file $remote:");

    }else{
	die "$file not found.";
    }
    &ssh_($remote, "rm -rf ./usr");
    &ssh_($remote, "tar xvzf $path[-1]");
}


sub create_archive{
    my($tag, $ver, @dirs)  = @_;
    my($prod) = "$CHROOT/usr/local/prod";
    my($lib, $archive);

    if($ver eq ""){
	$lib = "$prod/lib";
	$archive = "archive.tar.gz";
    }else{
	$lib = "$prod/lib.$ver";
	$archive = "archive.$ver.tar.gz";
    }
 
    &mkdir_($CHROOT);
    &install_dir("$prod/bin", "$prod/conf", "$lib");
    
    foreach my $d (@dirs){
	open(FIND, "find $d |") or die "find $d failed";
	while(<FIND>){
	    my($where, $dep, $name, $target);
	    chomp;
	    if(m|(.+)/target/.+jar-with-dependencies\.jar|){
		next;
	    }elsif(m|(.+)/target/dependency/([^/]+\.jar)|){
		($where, $dep, $name, $target) = ($1, 1, $2, $_);
	    }elsif(m|(.+)/target/([^/]+\.jar)|){
		($where, $dep, $name, $target) = ($1, 0, $2, $_);
	    }else{
		next;
	    }
	    my($w) = "$lib/$where";
	    if(! -d $w){
		&install_dir($w);
	    }
	    &install_file($target, "$w/$name");
	}
	close(FIND);
    }
    &archive_($CHROOT, $archive);
}

sub archive_{
    my($chroot, $archive)  = @_;
    chdir $chroot or die "cd $chroot failed";
    &run_("$TAR cvzf $archive ./usr");
    
    chdir $cwd or die "cd $cwd";
}

sub install_file{
    my($file, $dir, @opt) = @_;
    &install_($file, $dir, @opt);
}

sub install_{
    my($file, $dir, @opt) = @_;
    &run_("$INSTALL @opt $file $dir");
}

sub install_dir{
    my(@dir) = @_;
    foreach my $d (@dir){
	&run_("$INSTALL -d $d");
    }
}

sub get_dependencies{
    my(@deps);
    open(F, "mvn dependency:list |") or die "$mvn failed";
    if(! -f "pom.xml"){
	die "No pom.xml found.";
    }
    while(<F>){
	last if(m|\[INFO\] The following files have been resolved:|);
    }
    while(<F>){
	if(m|\INFO\] +(.+):(.+):(.+):(.+):(.+)|){
	    push @deps, ($1, $2, $3, $4, $5);
	}else{
	    last;
	}
    }
    close(F);
    print "@deps \n";
    return @deps;
}

sub ssh_{
    my($host, $command, @opt) = @_;
#    print "ssh $host $command @opt\n";
    &run_("ssh $host $command @opt");
}

sub run_{
    my($command) = @_;
    `$command`;
    if($?){
	die "$command failed";
    }
}

sub untar_{
    my($dir, $tgz) = @_;

    chdir $dir || die "cd $dir failed";
    open(TAR, "$TAR xvzf $cwd/$tgz 2>&1 |") or die $!;
    my $top;
    while(<TAR>){
	if(m/^x ([^\/]+)/){
	    $top = $1;
	}
    }
    close(TAR);

    if($top ne ""){
	return $top;
    }
    
    chdir $cwd || die "cd $dir failed";
}

sub get_tag{
    my($a) = @_;
    my($tag, $ver) = split(/:/, $a);
    if($tag eq ""){
	return ("time", $build_started);
    }else{
	if($tag eq "tag" and $ver ne ""){
	    return ("tag", $ver);
	}elsif($tag eq "rev" and $ver =~ m|[1-9][0-9]*|){
	    return ("rev", $ver);
	}else{
	    return ("time", $build_started);
	}
    }
}



sub create_script_{
    my($d, $file, $script) = @_;
    &mkdir_($d);
    my($f) = "$d/$file";
    open(SCRIPT, ">$f") or die "cannot create $f";
    print SCRIPT $script;
    close(SCRIPT);

    my($mode) = 0755;
    chmod $mode, $f || die "chmod $f failed";
}

sub mkdir_{
    my($d) = @_;
    if( ! -d $d){
	mkdir($d) or die "Cannot mkdir $d";
    }
}

sub findFile{
    my($file, @dirs) = @_;
    foreach my $d (@dirs){
	my($f) = "$d/$file";
	if( -f $f){
	    return $f
	}
    }
    die "$file not found in @dirs";
}

sub fetch{
    my($url, $cookie) = @_;
    my(@url) = split /\//, $url;
    my($curl);
    my($file) = $url[-1];

    if($cookie eq ""){
	$curl = "$CURL -j -L ";
    }else{
	$curl = "$CURL -j -k -L -H \"$cookie\" ";
    }

    $curl .= "$url > $file";
    if( ! -f $file){
	`$curl`;
	if($?){
	    die "$curl failed";
	}
    }
}

sub readVersion_{
    my($f) = @_;
    open(F, "$f") or die "cannot open $f";
    my($l) = <F>;
    close(F);
    my($R, $V) = &get_tag("l");
    return($R, $V);
}
sub writeVersion_{
    my($f, $r, $v) = @_;

    my($R, $V) = &get_tag("$r:$v");
    open(F, ">$f") or die "cannot create $f";
    print F "$R:$V";
    close(F);
}

sub usage_{
    my($prog) = @_;
    print STDERR <<"END_OF_USAGE";
usage:$prog setup jdk-id            # setup mvn & JAVA_HOME
      $prog checkout url            # checkout latest source from url
      $prog tag-checkout tag url    # checkout latest source from url with tag
      $prog rev-checkout rev url    # checkout latest source from url with rev
      $prog build [dirs]            # build and archive files to transfer

      $prog get-license dir [dirs]
END_OF_USAGE

    exit 1;
}
__END__


